/*************************************************************************
	> File Name: AmqpMessage.cpp
	> Author: 
	> Mail: 
	> Created Time: 2018年02月23日 星期五 16时38分53秒
 ************************************************************************/

#include <iostream>
#include <exception>
#include <malloc.h>
#include "AmqpMessage.h"
#include "../utils/sv_log.h"
using namespace std;


AmqpMessage::AmqpMessage()
{
    state = NULL;
    SV_LOG("构造函数 AmqpMessage");
}

AmqpMessage::~AmqpMessage()
{
    SV_LOG("析构函数 AmqpMessage");
}

//#ifdef __cplusplus
//extern "C" {
//#endif

//static amqp_connection_state_t conn = NULL;

static int die_on_amqp_error(amqp_rpc_reply_t x, char const *context)
{
    switch (x.reply_type)
    {
        case AMQP_RESPONSE_NORMAL:
            return AMQP_RESPONSE_NORMAL;

        case AMQP_RESPONSE_NONE:
            fprintf(stderr, "%s: missing RPC reply type!\n", context);
            SV_ERROR("%s: missing RPC reply type!\n", context);
            break;

        case AMQP_RESPONSE_LIBRARY_EXCEPTION:
            fprintf(stderr, "%s: %s\n", context, amqp_error_string2(x.library_error));
            SV_ERROR("%s: %s\n", context, amqp_error_string2(x.library_error));
        break;

        case AMQP_RESPONSE_SERVER_EXCEPTION:
            switch (x.reply.id)
            {
                case AMQP_CONNECTION_CLOSE_METHOD:
                {
                    amqp_connection_close_t *m = (amqp_connection_close_t *)x.reply.decoded;
                    fprintf(stderr, "%s: server connection error %uh, message: %.*s\n", context, m->reply_code, (int)m->reply_text.len, (char *)m->reply_text.bytes);
                    SV_ERROR("%s: server connection error %uh, message: %.*s\n", context, m->reply_code, (int)m->reply_text.len, (char *)m->reply_text.bytes);
                     break;
                            
                }
                case AMQP_CHANNEL_CLOSE_METHOD:
                {
                    amqp_channel_close_t *m = (amqp_channel_close_t *)x.reply.decoded;
                    fprintf(stderr, "%s: server channel error %uh, message: %.*s\n",context, m->reply_code, (int)m->reply_text.len, (char *)m->reply_text.bytes);
                    SV_ERROR("%s: server channel error %uh, message: %.*s\n",context, m->reply_code, (int)m->reply_text.len, (char *)m->reply_text.bytes);
                    return AMQP_CHANNEL_CLOSE_METHOD;  
                }
                default:
                    fprintf(stderr, "%s: unknown server error, method id 0x%08X\n", context, x.reply.id);
                    SV_ERROR("%s: unknown server error, method id 0x%08X\n", context, x.reply.id);
                    break;    
            }
            break;
    }

    return -1;
}

static int connection(amqp_connection_state_t *conn, const char *host, int port, const char *vm_host, const char *user, const char *password)
{
    amqp_socket_t *socket = NULL;
    int error = AMQP_RESPONSE_NONE;

    SV_LOG("2ddr %p", conn);
    if(vm_host == NULL || user == NULL || password == NULL)
    {
        SV_ERROR("parameter error");
        return -1;
    }
    if(*conn != NULL)
    {
        conn = NULL;
        SV_WARN("conn is not NULL");
    }

    *conn = amqp_new_connection();
    if(*conn == NULL)
    {
        SV_LOG("Fail to new amqp connection");
        return -1;
    }
    socket = amqp_tcp_socket_new(*conn);
    if(!socket)
    {
        SV_LOG("Fail to create TCP socket");
        return -1;
    }

    int status = amqp_socket_open(socket, host, port);
    if(status)
    {
        SV_LOG("Fail to open TCP socket");
        return -1;
    }

    error = die_on_amqp_error(amqp_login(*conn, vm_host, 0, 131072, 0, AMQP_SASL_METHOD_PLAIN, user, password), "amqp login");
    if(error != AMQP_RESPONSE_NORMAL)
    {
        return -1;
    }
    SV_LOG("3addr %p", conn);

    return 0;
}

static int creat_channel(amqp_connection_state_t conn)
{
    if(conn == NULL)
    {
        SV_ERROR("conn is NULL");
        return -1;
    }
    SV_LOG("creat_channel");
    amqp_channel_open(conn, 1);
    SV_LOG("1creat_channel");
    die_on_amqp_error(amqp_get_rpc_reply(conn), "open channel");
    SV_LOG("creat_channel");

    return 0;
}

static int declare_exchange(amqp_connection_state_t conn, const char *exchange, const char *type, int passive, int durable, int auto_delete, int internal)
{
    int error = AMQP_RESPONSE_NONE;

    amqp_exchange_declare(conn, 1, amqp_cstring_bytes(exchange), amqp_cstring_bytes(type), passive, durable, auto_delete, internal, amqp_empty_table);
    error = die_on_amqp_error(amqp_get_rpc_reply(conn), "declare exchange");
    if(error != AMQP_RESPONSE_NORMAL)
    {
        return -1;
    }

    return 0;
}


static int declare_queue(amqp_connection_state_t conn, const char *queuename, int passive, int durable, int exclusive, int auto_delete)
{
    int error = AMQP_RESPONSE_NONE;

    if(queuename == NULL)
    {
        SV_LOG("queuename is NULL");
        return -1;
    }

    SV_LOG("11");
    //amqp_queue_purge(conn, 1, amqp_cstring_bytes(queuename));
    die_on_amqp_error(amqp_get_rpc_reply(conn), "");
    SV_LOG("22 %s", queuename);
    amqp_queue_declare(conn, 1, amqp_cstring_bytes(queuename), passive, durable, exclusive, auto_delete, amqp_empty_table);
    SV_LOG("33");
    error = die_on_amqp_error(amqp_get_rpc_reply(conn), "declare queue error");
    if(error != AMQP_RESPONSE_NORMAL)
    {
        return -1;
    }

    return 0;
}

static int bind_queue(amqp_connection_state_t conn, const char *queuename, const char *exchange, const char *routing_key)
{
    int error = AMQP_RESPONSE_NONE;

    amqp_queue_bind(conn, 1, amqp_cstring_bytes(queuename), amqp_cstring_bytes(exchange), amqp_cstring_bytes(routing_key), amqp_empty_table);
    error = die_on_amqp_error(amqp_get_rpc_reply(conn), "bind queue");
    if(error != AMQP_RESPONSE_NORMAL)
    {
        return -1;
    }

    return 0;
}


static char* receive_message(amqp_connection_state_t conn)
{
    amqp_rpc_reply_t res;
    amqp_envelope_t envelope;

    SV_LOG("receive_message");
    amqp_maybe_release_buffers(conn);
    res = amqp_consume_message(conn, &envelope, NULL, 0);
    SV_LOG("receive_message a message");
    if(res.reply_type != AMQP_RESPONSE_NORMAL)
    {
        SV_ERROR("read message error");
        return NULL;
    }
    if(envelope.message.body.bytes != NULL || envelope.message.body.len <= 0)
    {
        return NULL;
    }
    char *message = (char *) malloc(envelope.message.body.len * sizeof(char));
    if(message == NULL)
    {
        SV_ERROR("malloc error");
        return NULL;
    }
    memcpy(message, envelope.message.body.bytes, envelope.message.body.len);
    
    return message;
}

//#ifdef __cplusplus
//}
//#endif

void AmqpMessage::Connection(string &ip, int port, string &virtualHost, string &userName, string &password) 
{
    if(ip.empty() || port <= 0 || virtualHost.empty() || userName.empty() || password.empty())
    {
        SV_ERROR("parameter error");
        throw -1;
    }
    
    SV_LOG("connect mq server: ip: %s, port: %d, virtualHost: %s, userName: %s, password: %s", ip.c_str(), port, virtualHost.c_str(), userName.c_str(), password.c_str());
    SV_LOG("addr %p", &state);
    int res = connection(&state, ip.c_str(), port, virtualHost.c_str(), userName.c_str(), password.c_str());
    SV_LOG("1addr %p", &state);
    if(res != 0)
    {
        SV_ERROR("Connection error");
        throw -1;
    }
    if(state == NULL)
    {
        SV_ERROR("connect null");
    }
}

void AmqpMessage::CreateChannel()
{
    if(state == NULL)
    {
        SV_ERROR("can not create channel");
        throw -1;
    }
    SV_LOG("create channel");
    int res = creat_channel(state);
    if(res != 0)
    {
        SV_ERROR("create channel error");
        throw -1;
    }
}

void AmqpMessage::ExchangeDeclare(string &exchange, string &exchangeType, int passive, int durable, int auto_delete, int internal)
{
    int res = declare_exchange(state, exchange.c_str(), exchangeType.c_str(), passive, durable, auto_delete, internal);
    if(res != 0)
    {
        SV_ERROR("declare exchange error");
        //throw -1;
    }
}

void AmqpMessage::QueueDeclare(string &queueName, int passive, int durable, int exclusive, int auto_delete)
{
    SV_LOG("declare queue : %s", queueName.c_str());
    int res = declare_queue(state, queueName.c_str(), passive, durable, exclusive, auto_delete);
    if(res != 0)
    {
        SV_ERROR("declare queue error");
        throw -1;
    }
}

void AmqpMessage::QueueBind(string &queuename, string &exchange, string &routingKey)
{
    SV_LOG("bind queue : queue = %s, exchange = %s, routing_key = %s", queuename.c_str(), exchange.c_str(), routingKey.c_str());
    int res = bind_queue(state, queuename.c_str(), exchange.c_str(), routingKey.c_str());
    if(res != 0)
    {
        SV_ERROR("bind queue error");
        throw -1;
    }
}

void AmqpMessage::ReceiveMessage(string &message)
{
    char *buf = receive_message(state);
    if(buf == NULL)
    {
        SV_ERROR("start consumer error");
        //throw -1;
    }
    SV_LOG("%s", buf);
    message = buf;
    free(buf);
}

void AmqpMessage::StartConsume()
{
    string message;
    
    SV_LOG("start consume");
    while(1)
    {
        message = "";
        ReceiveMessage(message);
        sleep(1);
    }
}

