/*
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MIT
 *
 * Portions created by Alan Antonuk are Copyright (c) 2012-2013
 * Alan Antonuk. All Rights Reserved.
 *
 * Portions created by VMware are Copyright (c) 2007-2012 VMware, Inc.
 * All Rights Reserved.
 *
 * Portions created by Tony Garnock-Jones are Copyright (c) 2009-2010
 * VMware, Inc. and Tony Garnock-Jones. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * ***** END LICENSE BLOCK *****
 */

#include <iostream>
#include <string>
#include <log4cplus/logger.h>
#include <log4cplus/loggingmacros.h>
#include <log4cplus/configurator.h>
#include <log4cplus/layout.h>
#include <iomanip>
#include "amqp_receive_msg.h"
 
log4cplus::BasicConfigurator config;
log4cplus::Logger logger;
 
using namespace std;
#ifdef __cplusplus
extern "C" { 
#endif

#include <unistd.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <time.h>
#include <amqp.h>
#include <amqp_tcp_socket.h>
#define SUMMARY_EVERY_US 1000

uint64_t now_microseconds(void) {
          struct timeval tv;
          gettimeofday(&tv, NULL);
          return (uint64_t)tv.tv_sec * 1000000 + (uint64_t)tv.tv_usec;

}


static void dump_row(long count, int numinrow, int *chs) {
  int i;

  printf("%08lX:", count - numinrow);

  if (numinrow > 0) {
    for (i = 0; i < numinrow; i++) {
      if (i == 8) {
        printf(" :");
      }
      printf(" %02X", chs[i]);
    }
    for (i = numinrow; i < 16; i++) {
      if (i == 8) {
        printf(" :");
      }
      printf("   ");
    }
    printf("  ");
    for (i = 0; i < numinrow; i++) {
      if (isprint(chs[i])) {
        printf("%c", chs[i]);
      } else {
        printf(".");
      }
    }
  }
  printf("\n");
}

static int rows_eq(int *a, int *b) {
  int i;

  for (i = 0; i < 16; i++)
    if (a[i] != b[i]) {
      return 0;
    }

  return 1;
}

void amqp_dump(void const *buffer, size_t len) {
  unsigned char *buf = (unsigned char *)buffer;
  long count = 0;
  int numinrow = 0;
  int chs[16];
  int oldchs[16] = {0};
  int showed_dots = 0;
  size_t i;

  for (i = 0; i < len; i++) {
    int ch = buf[i];

    if (numinrow == 16) {
      int j;

      if (rows_eq(oldchs, chs)) {
        if (!showed_dots) {
          showed_dots = 1;
          printf(
              "          .. .. .. .. .. .. .. .. : .. .. .. .. .. .. .. ..\n");
        }
      } else {
        showed_dots = 0;
        dump_row(count, numinrow, chs);
      }

      for (j = 0; j < 16; j++) {
        oldchs[j] = chs[j];
      }

      numinrow = 0;
    }

    count++;
    chs[numinrow++] = ch;
  }

  dump_row(count, numinrow, chs);

  if (numinrow != 0) {
    printf("%08lX:\n", count);
  }
}


static void run(amqp_connection_state_t conn) {
  uint64_t start_time = now_microseconds();
  int received = 0;
  int previous_received = 0;
  uint64_t previous_report_time = start_time;
  uint64_t next_summary_time = start_time + SUMMARY_EVERY_US;

  //amqp_frame_t frame;

  uint64_t now;
    char tmp[4096] = {0};

	for (;;) {
		amqp_rpc_reply_t ret;
		amqp_envelope_t envelope;
    LOG4CPLUS_INFO(logger, "hello world");

    LOG4CPLUS_INFO(logger, now);
		now = now_microseconds();
		if (now) {
			int countOverInterval = received - previous_received;
			double intervalRate =
			countOverInterval / ((now - previous_report_time) / 1000000.0);
			snprintf(tmp, 4096, "%d ms: Received %d - %d since last report (%d Hz)\n",
             (int)(now - start_time) / 1000, received, countOverInterval,
             (int)intervalRate);
            LOG4CPLUS_INFO(logger, tmp);

			previous_received = received;
			previous_report_time = now;
			next_summary_time += SUMMARY_EVERY_US;
		}

        LOG4CPLUS_INFO(logger, "hello world1112");
		amqp_maybe_release_buffers(conn);
        LOG4CPLUS_INFO(logger, "hello world1113");
		ret = amqp_consume_message(conn, &envelope, NULL, 0);
        LOG4CPLUS_INFO(logger, "hello world114");
		
		if (AMQP_RESPONSE_NORMAL != ret.reply_type) {
			break;
		}

        memset(tmp,0, sizeof(tmp));
		snprintf(tmp, 4096, "Delivery %u, exchange %.*s routingkey %.*s\n",
             (unsigned)envelope.delivery_tag, (int)envelope.exchange.len,
             (char *)envelope.exchange.bytes, (int)envelope.routing_key.len,
             (char *)envelope.routing_key.bytes);
        LOG4CPLUS_INFO(logger, tmp);
        LOG4CPLUS_INFO(logger, "hello world222");

		if (envelope.message.properties._flags & AMQP_BASIC_CONTENT_TYPE_FLAG) {
			printf("Content-type: %.*s\n",
               (int)envelope.message.properties.content_type.len,
               (char *)envelope.message.properties.content_type.bytes);
		}
		printf("----\n");

		amqp_dump(envelope.message.body.bytes, envelope.message.body.len);

		amqp_destroy_envelope(&envelope);
		
		// if (AMQP_RESPONSE_NORMAL != ret.reply_type) {
			// if (AMQP_RESPONSE_LIBRARY_EXCEPTION == ret.reply_type &&
				// AMQP_STATUS_UNEXPECTED_STATE == ret.library_error)
			// {
				// if (AMQP_STATUS_OK != amqp_simple_wait_frame(conn, &frame))
				// {
					// return;
				// }

				// if (AMQP_FRAME_METHOD == frame.frame_type)
				// {
					// switch (frame.payload.method.id) 
					// {
						// case AMQP_BASIC_ACK_METHOD:
						// /* if we've turned publisher confirms on, and we've published a
						// * message here is a message being confirmed.
						// */
							// break;
						// case AMQP_BASIC_RETURN_METHOD:
						// /* if a published message couldn't be routed and the mandatory
						// * flag was set this is what would be returned. The message then
						// * needs to be read.
						// */
						// {
							// amqp_message_t message;
							// ret = amqp_read_message(conn, frame.channel, &message, 0);
							// if (AMQP_RESPONSE_NORMAL != ret.reply_type)
							// {
								// return;
							// }

							// amqp_destroy_message(&message);
						// }

						// break;

					// case AMQP_CHANNEL_CLOSE_METHOD:
						// /* a channel.close method happens when a channel exception occurs,
						// * this can happen by publishing to an exchange that doesn't exist
						// * for example.
						// *
						// * In this case you would need to open another channel redeclare
						// * any queues that were declared auto-delete, and restart any
						// * consumers that were attached to the previous channel.
						// */
						// return;
	
					// case AMQP_CONNECTION_CLOSE_METHOD:
						// /* a connection.close method happens when a connection exception
						// * occurs, this can happen by trying to use a channel that isn't
						// * open for example.
						// *
						// * In this case the whole connection must be restarted.
						// */
						// return;

					// default:
						// fprintf(stderr, "An unexpected method was received %u\n",
							// frame.payload.method.id);
						// return;
					// }
				// }
			// }

		// } else {
			// amqp_destroy_envelope(&envelope);
		// }
		// */

    LOG4CPLUS_INFO(logger, "hello world");
        sleep(2);
		received++;
	}
}

int receive_msg(const char *hostname, int port, const char *queue, const char *exchange, const char *routingkey) {

	amqp_socket_t *socket = NULL;
	amqp_connection_state_t conn;
	amqp_rpc_reply_t reply;
    amqp_bytes_t queuename;
    char const *bindingkey = NULL;
    bindingkey = routingkey;


	conn = amqp_new_connection();

	socket = amqp_tcp_socket_new(conn);
	if (!socket) {
		printf("creating TCP socket");
		return 0;
	}

    LOG4CPLUS_INFO(logger, hostname);
	int status = amqp_socket_open(socket, hostname, port);
	if (status) {
		printf("opening TCP socket");
		return 0;
	}

    LOG4CPLUS_INFO(logger, hostname);
	reply = amqp_login(conn, "/", 0, 131072, 0, AMQP_SASL_METHOD_PLAIN,
                               "admin", "admin");
	if(reply.reply_type == AMQP_RESPONSE_LIBRARY_EXCEPTION)
	{
		printf("amqp login error\n");
		return 0;
	}
                    
	amqp_channel_open(conn, 1);
	reply = amqp_get_rpc_reply(conn);
	if(reply.reply_type == AMQP_RESPONSE_LIBRARY_EXCEPTION)
	{
		printf("amqp login error\n");
		return 0;
	}
    LOG4CPLUS_INFO(logger, "qqhello world");
    amqp_exchange_declare(conn, 1, amqp_cstring_bytes(exchange), amqp_cstring_bytes("direct"), 0, 1, 0, 0, amqp_empty_table);
    LOG4CPLUS_INFO(logger, "1hello world");
	
	
	{
        amqp_queue_declare_ok_t *r = amqp_queue_declare(conn, 1, amqp_cstring_bytes("172_16_17_118"), 0, 0, 0, 0, amqp_empty_table);
        amqp_get_rpc_reply(conn);
        if(&(r->queue) == NULL)
        {
    LOG4CPLUS_INFO(logger, queue);
            LOG4CPLUS_INFO(logger, "queue exist");
            queuename.len = strlen(queue);
            queuename.bytes = malloc(queuename.len);
            memcpy(queuename.bytes, queue, queuename.len);
            //return 1;
        }else{
            LOG4CPLUS_INFO(logger, "queue no exist");
             memset(&queuename, 0, sizeof(queuename));
		    queuename = amqp_bytes_malloc_dup(r->queue);
            LOG4CPLUS_INFO(logger, queue);
		    if (queuename.bytes == NULL) {
			    //fprintf(stderr, "Out of memory while copying queue name");
                return 1;
		    }
        }  
    }
    
	
	//amqp_queue_declare(conn, 1, amqp_empty_bytes, 0, 0, 0, 1, amqp_empty);
	
    LOG4CPLUS_INFO(logger, exchange);
    LOG4CPLUS_INFO(logger, routingkey);
	amqp_queue_bind(conn, 1, queuename, amqp_cstring_bytes(exchange), amqp_cstring_bytes(routingkey), amqp_empty_table);
	//amqp_queue_bind(conn, 1, queuename, amqp_cstring_bytes(exchange), amqp_cstring_bytes(bindingkey), amqp_empty_table);
                  
    LOG4CPLUS_INFO(logger, "5hello world");
	amqp_get_rpc_reply(conn);
    LOG4CPLUS_INFO(logger, "5hello world");
	
	//amqp_basic_consume(conn, 1, amqp_cstring-bytes("192_168_2_129"), amqp_empty_bytes, 0, 1, 0, amqp_empty_table);
    amqp_basic_consume(conn, 1, queuename, amqp_empty_bytes, 0, 1, 0, amqp_empty_table);                
	reply = amqp_get_rpc_reply(conn);
    LOG4CPLUS_INFO(logger, "6hello world");
	if(reply.reply_type == AMQP_RESPONSE_LIBRARY_EXCEPTION)
	{
		printf("amqp login error\n");
		return 0;
	}

    LOG4CPLUS_INFO(logger, "2hello world");
	run(conn);
    LOG4CPLUS_INFO(logger, "3hello world");

	amqp_channel_close(conn, 1, AMQP_REPLY_SUCCESS);
	amqp_connection_close(conn, AMQP_REPLY_SUCCESS);
	amqp_destroy_connection(conn);
	return 0;
}

#ifdef __cplusplus
}
#endif

int receive_message(string &hostname, int port, string &queue, string &exchange, string &routingkey)
{
    config.configure();
    logger = log4cplus::Logger::getInstance("main");
    LOG4CPLUS_INFO(logger, "hello world");
	receive_msg(hostname.c_str(), port, queue.c_str(), exchange.c_str(), routingkey.c_str());

    return 0;
}

/*int main()
{
	sendStr("172.16.17.118", 5672, "amq.direct", "test", "xusheng test");
	
	return 0;
}*/
